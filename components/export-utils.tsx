"use client"

import { useRef } from "react"
import { Download, FileSpreadsheet, FileIcon as FilePdf } from "lucide-react"
import { jsPDF } from "jspdf"
import * as XLSX from "xlsx"

import { Button } from "@/components/ui/button"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"
import {
  type AssessmentResult,
  type Domain,
  calculateDimensionAverages,
  calculateDomainAverages,
  calculateOverallAverage,
  dimensions,
  domains,
  getMaturityLevel,
} from "@/lib/assessment-data"

interface ExportUtilsProps {
  results: AssessmentResult
  organizationName?: string
}

export function ExportUtils({ results, organizationName = "Your Organization" }: ExportUtilsProps) {
  const tableRef = useRef<HTMLDivElement>(null)

  const trackDownload = async (type: string, organizationName: string) => {
    try {
      // In a real implementation, this would send data to a server
      const downloadData = {
        type,
        module: "Maturity Assessment",
        organization: organizationName,
        date: new Date().toISOString(),
      }

      // For now, just log to console
      console.log("Download tracked:", downloadData)

      // Store in localStorage for admin dashboard to access
      const downloads = JSON.parse(localStorage.getItem("tracked_downloads") || "[]")
      downloads.push(downloadData)
      localStorage.setItem("tracked_downloads", JSON.stringify(downloads))

      // No API call needed
    } catch (error) {
      console.error("Error tracking download:", error)
    }
  }

  const exportToPDF = () => {
    const doc = new jsPDF({
      orientation: "portrait",
      unit: "mm",
      format: "a4",
    })

    // Add title and date
    doc.setFontSize(18)
    doc.text("Legal IT Maturity Assessment Report", 15, 15)
    doc.setFontSize(12)
    doc.text(`Organization: ${organizationName}`, 15, 25)
    doc.text(`Date: ${new Date().toLocaleDateString()}`, 15, 32)

    // Add overall score
    const overallAverage = calculateOverallAverage(results)
    doc.setFontSize(14)
    doc.text("Overall Maturity Score", 15, 45)
    doc.setFontSize(24)
    doc.text(`${overallAverage.toFixed(1)} - ${getMaturityLevel(overallAverage)}`, 15, 55)

    // Add domain scores
    doc.setFontSize(14)
    doc.text("Domain Scores", 15, 70)

    const domainAverages = calculateDomainAverages(results)
    let yPos = 80

    domains.forEach((domain: Domain) => {
      const score = domainAverages[domain.id] || 0
      if (score > 0) {
        doc.setFontSize(12)
        doc.text(`${domain.name}: ${score.toFixed(1)} - ${getMaturityLevel(score)}`, 20, yPos)
        yPos += 8
      }
    })

    // Add dimension scores
    yPos += 10
    doc.setFontSize(14)
    doc.text("Dimension Scores", 15, yPos)

    const dimensionAverages = calculateDimensionAverages(results)
    yPos += 10

    Object.entries(dimensions).forEach(([key, value]) => {
      const score = dimensionAverages[key] || 0
      if (score > 0) {
        doc.setFontSize(12)
        doc.text(`${value.name}: ${score.toFixed(1)} - ${getMaturityLevel(score)}`, 20, yPos)
        yPos += 8
      }
    })

    // Add domain-specific sections with recommendations
    let currentPage = 1
    domains.forEach((domain: Domain) => {
      const domainScore = domainAverages[domain.id] || 0
      if (domainScore > 0) {
        // Add a new page for each domain
        doc.addPage()
        currentPage++

        // Domain header
        doc.setFontSize(16)
        doc.text(`${domain.name} Domain Analysis`, 15, 15)

        // Domain score
        doc.setFontSize(14)
        doc.text(`Maturity Level: ${getMaturityLevel(domainScore)} (${domainScore.toFixed(1)})`, 15, 25)

        // Dimension scores for this domain
        doc.setFontSize(12)
        doc.text("Dimension Scores:", 15, 35)

        let dimYPos = 45
        Object.entries(dimensions).forEach(([key, value]) => {
          const score = results[domain.id][key as keyof (typeof results)[string]] || 0
          if (score > 0) {
            doc.text(`${value.name}: ${score.toFixed(1)} - ${getMaturityLevel(score)}`, 20, dimYPos)
            dimYPos += 8
          }
        })

        // Add recommendations based on maturity level
        doc.setFontSize(14)
        doc.text("Recommendations:", 15, dimYPos + 10)

        const recommendations = getRecommendations(domain.id, domainScore)
        let recYPos = dimYPos + 20

        recommendations.forEach((rec, index) => {
          doc.setFontSize(10)
          doc.text(`${index + 1}. ${rec}`, 20, recYPos)
          recYPos += 8
        })
      }
    })

    // Add footer
    doc.setFontSize(10)
    doc.text("Generated by Legal IT Maturity Assessment Tool", 15, 280)
    doc.text("Developed by Maz Araghrez, Legal Technologist at Dentons", 15, 285)

    // Track the download
    trackDownload("PDF", organizationName)

    // Save the PDF
    doc.save(`${organizationName.replace(/\s+/g, "_")}_IT_Maturity_Assessment.pdf`)
  }

  const exportToExcel = () => {
    const domainAverages = calculateDomainAverages(results)
    const dimensionAverages = calculateDimensionAverages(results)
    const overallAverage = calculateOverallAverage(results)

    // Create worksheet for summary
    const summaryData = [
      ["Legal IT Maturity Assessment Report"],
      [`Organization: ${organizationName}`],
      [`Date: ${new Date().toLocaleDateString()}`],
      [],
      ["Overall Maturity Score", overallAverage.toFixed(1), getMaturityLevel(overallAverage)],
      [],
      ["Domain Scores"],
    ]

    domains.forEach((domain: Domain) => {
      const score = domainAverages[domain.id] || 0
      if (score > 0) {
        summaryData.push([domain.name, score.toFixed(1), getMaturityLevel(score)])
      }
    })

    summaryData.push([])
    summaryData.push(["Dimension Scores"])

    Object.entries(dimensions).forEach(([key, value]) => {
      const score = dimensionAverages[key] || 0
      if (score > 0) {
        summaryData.push([value.name, score.toFixed(1), getMaturityLevel(score)])
      }
    })

    // Create worksheet for detailed scores
    const detailedData = [
      ["Domain", "People & Organization", "Process", "Tooling", "Data", "Continual Improvement", "Average"],
    ]

    domains.forEach((domain: Domain) => {
      detailedData.push([
        domain.name,
        results[domain.id].people || "-",
        results[domain.id].process || "-",
        results[domain.id].tooling || "-",
        results[domain.id].data || "-",
        results[domain.id].improvement || "-",
        domainAverages[domain.id] ? domainAverages[domain.id].toFixed(1) : "-",
      ])
    })

    detailedData.push([
      "Dimension Average",
      dimensionAverages.people ? dimensionAverages.people.toFixed(1) : "-",
      dimensionAverages.process ? dimensionAverages.process.toFixed(1) : "-",
      dimensionAverages.tooling ? dimensionAverages.tooling.toFixed(1) : "-",
      dimensionAverages.data ? dimensionAverages.data.toFixed(1) : "-",
      dimensionAverages.improvement ? dimensionAverages.improvement.toFixed(1) : "-",
      overallAverage.toFixed(1),
    ])

    // Create domain-specific worksheets with recommendations
    const domainSheets = domains
      .map((domain: Domain) => {
        const domainScore = domainAverages[domain.id] || 0
        if (domainScore <= 0) return null

        const sheetData = [
          [`${domain.name} Domain Analysis`],
          [],
          ["Maturity Level", domainScore.toFixed(1), getMaturityLevel(domainScore)],
          [],
          ["Dimension", "Score", "Maturity Level"],
        ]

        Object.entries(dimensions).forEach(([key, value]) => {
          const score = results[domain.id][key as keyof (typeof results)[string]] || 0
          if (score > 0) {
            sheetData.push([value.name, score.toFixed(1), getMaturityLevel(score)])
          }
        })

        sheetData.push([])
        sheetData.push(["Recommendations"])

        const recommendations = getRecommendations(domain.id, domainScore)
        recommendations.forEach((rec, index) => {
          sheetData.push([`${index + 1}. ${rec}`])
        })

        return {
          name: domain.name.replace(/\s+/g, "_"),
          data: sheetData,
        }
      })
      .filter(Boolean)

    // Create workbook with all worksheets
    const wb = XLSX.utils.book_new()
    const summaryWs = XLSX.utils.aoa_to_sheet(summaryData)
    const detailedWs = XLSX.utils.aoa_to_sheet(detailedData)

    XLSX.utils.book_append_sheet(wb, summaryWs, "Summary")
    XLSX.utils.book_append_sheet(wb, detailedWs, "Detailed Scores")

    // Add domain-specific sheets
    domainSheets.forEach((sheet) => {
      if (sheet) {
        const ws = XLSX.utils.aoa_to_sheet(sheet.data)
        XLSX.utils.book_append_sheet(wb, ws, sheet.name)
      }
    })

    // Track the download
    trackDownload("Excel", organizationName)

    // Save the Excel file
    XLSX.writeFile(wb, `${organizationName.replace(/\s+/g, "_")}_IT_Maturity_Assessment.xlsx`)
  }

  // Helper function to get recommendations based on domain and score
  const getRecommendations = (domainId: string, score: number): string[] => {
    // Default recommendations if no specific ones are available
    const defaultRecs = [
      "Establish formal processes and documentation",
      "Implement regular reviews and improvement cycles",
      "Invest in training and skill development",
      "Standardize tools and technologies",
      "Develop metrics to measure effectiveness",
    ]

    // Domain-specific recommendations based on maturity level
    const recommendationsByDomain: Record<string, Record<string, string[]>> = {
      "service-management": {
        Initial: [
          "Establish basic service catalog with clear definitions",
          "Define core service level targets for critical services",
          "Implement a simple ticketing system for service requests",
          "Assign clear ownership for key services",
          "Document basic service management processes",
        ],
        Managed: [
          "Formalize service level agreements (SLAs) with business units",
          "Implement regular service reviews with stakeholders",
          "Enhance service catalog with detailed descriptions and request processes",
          "Develop service performance metrics and reporting",
          "Establish a service management framework based on ITIL principles",
        ],
        // Add more maturity levels as needed
      },
      // Add more domains as needed
    }

    // Get the maturity level
    const maturityLevel = getMaturityLevel(score)

    // Try to get domain-specific recommendations
    if (recommendationsByDomain[domainId] && recommendationsByDomain[domainId][maturityLevel]) {
      return recommendationsByDomain[domainId][maturityLevel]
    }

    // Fall back to default recommendations
    return defaultRecs
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="gap-2">
          <Download className="h-4 w-4" />
          Export Results
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={exportToPDF} className="gap-2 cursor-pointer">
          <FilePdf className="h-4 w-4" />
          Export as PDF
        </DropdownMenuItem>
        <DropdownMenuItem onClick={exportToExcel} className="gap-2 cursor-pointer">
          <FileSpreadsheet className="h-4 w-4" />
          Export as Excel
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

// Also export the utility functions for use in other components
export const handlePdfExport = (results: any, organizationName = "Your Organization") => {
  // Create a temporary ExportUtils instance and call its exportToPDF method
  const tempExportUtils = {
    results,
    organizationName,
    exportToPDF: function () {
      const doc = new jsPDF({
        orientation: "portrait",
        unit: "mm",
        format: "a4",
      })

      // Add basic content
      doc.setFontSize(18)
      doc.text("Legal IT Maturity Assessment Report", 15, 15)
      doc.setFontSize(12)
      doc.text(`Organization: ${this.organizationName}`, 15, 25)

      // Save the PDF
      doc.save(`${this.organizationName.replace(/\s+/g, "_")}_IT_Maturity_Assessment.pdf`)
    },
  }

  tempExportUtils.exportToPDF()
}

export const handleExcelExport = (results: any, organizationName = "Your Organization") => {
  // Create a temporary ExportUtils instance and call its exportToExcel method
  const tempExportUtils = {
    results,
    organizationName,
    exportToExcel: function () {
      // Create a simple workbook
      const wb = XLSX.utils.book_new()
      const ws = XLSX.utils.json_to_sheet([
        {
          Organization: this.organizationName,
          Date: new Date().toLocaleDateString(),
        },
      ])

      XLSX.utils.book_append_sheet(wb, ws, "Summary")

      // Save the Excel file
      XLSX.writeFile(wb, `${this.organizationName.replace(/\s+/g, "_")}_IT_Maturity_Assessment.xlsx`)
    },
  }

  tempExportUtils.exportToExcel()
}
