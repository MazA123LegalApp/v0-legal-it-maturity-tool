"use client"

import { useRef, useEffect, useState } from "react"
import { Download, FileSpreadsheet, FileIcon as FilePdf } from "lucide-react"
import { jsPDF } from "jspdf"
import * as XLSX from "xlsx"
import { trackAssessmentDownload } from "@/lib/tracking-utils"

import { Button } from "@/components/ui/button"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"
import {
  type AssessmentResult,
  type Domain,
  calculateDimensionAverages,
  calculateDomainAverages,
  calculateOverallAverage,
  dimensions,
  domains,
  getMaturityLevel,
} from "@/lib/assessment-data"
import { getCountryInfo } from "@/lib/geo-utils"

interface ExportUtilsProps {
  results: AssessmentResult
  organizationName?: string
}

// Define window.trackDownload if it doesn't exist in the type system
declare global {
  interface Window {
    trackDownload?: (fileType: string, fileName: string, isUSBased: boolean) => void
    gtag?: (event: string, action: string, eventParams: any) => void
  }
}

export function ExportUtils({ results, organizationName = "Your Organization" }: ExportUtilsProps) {
  const tableRef = useRef<HTMLDivElement>(null)
  const [isUS, setIsUS] = useState<boolean>(false)

  // Check if user is from the US
  useEffect(() => {
    const checkLocation = async () => {
      try {
        const countryInfo = await getCountryInfo()
        setIsUS(countryInfo.isUS)
      } catch (error) {
        console.error("Error checking location:", error)
      }
    }

    checkLocation()
  }, [])

  const exportToPDF = () => {
    try {
      const doc = new jsPDF({
        orientation: "portrait",
        unit: "mm",
        format: "a4",
      })

      // Add title and date
      doc.setFontSize(18)
      doc.text("Legal IT Maturity Assessment Report", 15, 15)
      doc.setFontSize(12)
      doc.text(`Organization: ${organizationName}`, 15, 25)
      doc.text(`Date: ${new Date().toLocaleDateString()}`, 15, 32)

      // Add overall score
      const overallAverage = calculateOverallAverage(results)
      doc.setFontSize(14)
      doc.text("Overall Maturity Score", 15, 45)
      doc.setFontSize(24)
      doc.text(`${overallAverage.toFixed(1)} - ${getMaturityLevel(overallAverage)}`, 15, 55)

      // Add domain scores
      doc.setFontSize(14)
      doc.text("Domain Scores", 15, 70)

      const domainAverages = calculateDomainAverages(results)
      let yPos = 80

      domains.forEach((domain: Domain) => {
        const score = domainAverages[domain.id] || 0
        if (score > 0) {
          doc.setFontSize(12)
          doc.text(`${domain.name}: ${score.toFixed(1)} - ${getMaturityLevel(score)}`, 20, yPos)
          yPos += 8
        }
      })

      // Add dimension scores
      yPos += 10
      doc.setFontSize(14)
      doc.text("Dimension Scores", 15, yPos)

      const dimensionAverages = calculateDimensionAverages(results)
      yPos += 10

      Object.entries(dimensions).forEach(([key, value]) => {
        const score = dimensionAverages[key] || 0
        if (score > 0) {
          doc.setFontSize(12)
          doc.text(`${value.name}: ${score.toFixed(1)} - ${getMaturityLevel(score)}`, 20, yPos)
          yPos += 8
        }
      })

      // Add footer
      doc.setFontSize(10)
      doc.text("Generated by Legal IT Maturity Assessment Tool", 15, 280)
      doc.text("Developed by Maz Araghrez, Legal Technologist at Dentons", 15, 285)

      // Track the download
      trackAssessmentDownload("PDF", organizationName, isUS)

      // Save the PDF
      doc.save(`${organizationName.replace(/\s+/g, "_")}_IT_Maturity_Assessment.pdf`)
    } catch (error) {
      console.error("Error exporting to PDF:", error)
      // Continue even if there's an error
    }
  }

  // Helper function to split text to fit within a width
  function splitTextToFit(text: string, maxWidth: number, doc: jsPDF): string[] {
    const words = text.split(" ")
    const lines: string[] = []
    let currentLine = ""

    words.forEach((word) => {
      const testLine = currentLine ? `${currentLine} ${word}` : word
      const testWidth = doc.getTextWidth(testLine)

      if (testWidth > maxWidth) {
        lines.push(currentLine)
        currentLine = word
      } else {
        currentLine = testLine
      }
    })

    if (currentLine) {
      lines.push(currentLine)
    }

    return lines
  }

  const exportToExcel = () => {
    try {
      const domainAverages = calculateDomainAverages(results)
      const dimensionAverages = calculateDimensionAverages(results)
      const overallAverage = calculateOverallAverage(results)

      // Create worksheet for summary
      const summaryData = [
        ["Legal IT Maturity Assessment Report"],
        [`Organization: ${organizationName}`],
        [`Date: ${new Date().toLocaleDateString()}`],
        [],
        ["Overall Maturity Score", overallAverage.toFixed(1), getMaturityLevel(overallAverage)],
        [],
        ["Domain Scores"],
      ]

      domains.forEach((domain: Domain) => {
        const score = domainAverages[domain.id] || 0
        if (score > 0) {
          summaryData.push([domain.name, score.toFixed(1), getMaturityLevel(score)])
        }
      })

      summaryData.push([])
      summaryData.push(["Dimension Scores"])

      Object.entries(dimensions).forEach(([key, value]) => {
        const score = dimensionAverages[key] || 0
        if (score > 0) {
          summaryData.push([value.name, score.toFixed(1), getMaturityLevel(score)])
        }
      })

      // Create worksheet for detailed scores
      const detailedData = [
        ["Domain", "People & Organization", "Process", "Tooling", "Data", "Continual Improvement", "Average"],
      ]

      domains.forEach((domain: Domain) => {
        detailedData.push([
          domain.name,
          results[domain.id]?.people || "-",
          results[domain.id]?.process || "-",
          results[domain.id]?.tooling || "-",
          results[domain.id]?.data || "-",
          results[domain.id]?.improvement || "-",
          domainAverages[domain.id] ? domainAverages[domain.id].toFixed(1) : "-",
        ])
      })

      detailedData.push([
        "Dimension Average",
        dimensionAverages.people ? dimensionAverages.people.toFixed(1) : "-",
        dimensionAverages.process ? dimensionAverages.process.toFixed(1) : "-",
        dimensionAverages.tooling ? dimensionAverages.tooling.toFixed(1) : "-",
        dimensionAverages.data ? dimensionAverages.data.toFixed(1) : "-",
        dimensionAverages.improvement ? dimensionAverages.improvement.toFixed(1) : "-",
        overallAverage.toFixed(1),
      ])

      // Create workbook with all worksheets
      const wb = XLSX.utils.book_new()
      const summaryWs = XLSX.utils.aoa_to_sheet(summaryData)
      const detailedWs = XLSX.utils.aoa_to_sheet(detailedData)

      XLSX.utils.book_append_sheet(wb, summaryWs, "Summary")
      XLSX.utils.book_append_sheet(wb, detailedWs, "Detailed Scores")

      // Track the download
      trackAssessmentDownload("Excel", organizationName, isUS)

      // Save the Excel file
      XLSX.writeFile(wb, `${organizationName.replace(/\s+/g, "_")}_IT_Maturity_Assessment.xlsx`)
    } catch (error) {
      console.error("Error exporting to Excel:", error)
      // Continue even if there's an error
    }
  }

  // Helper function to get recommendations based on domain and score
  const getRecommendations = (domainId: string, score: number): string[] => {
    // Default recommendations if no specific ones are available
    const defaultRecs = [
      "Establish formal processes and documentation",
      "Implement regular reviews and improvement cycles",
      "Invest in training and skill development",
      "Standardize tools and technologies",
      "Develop metrics to measure effectiveness",
    ]

    // Get the maturity level
    const maturityLevel = getMaturityLevel(score)

    // Fall back to default recommendations
    return defaultRecs
  }

  const getTemplatesForDomain = (domainId: string, maturityBand: string): any[] => {
    // Placeholder for template data retrieval logic
    return []
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="gap-2">
          <Download className="h-4 w-4" />
          Export Results
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={exportToPDF} className="gap-2 cursor-pointer">
          <FilePdf className="h-4 w-4" />
          Export as PDF
        </DropdownMenuItem>
        <DropdownMenuItem onClick={exportToExcel} className="gap-2 cursor-pointer">
          <FileSpreadsheet className="h-4 w-4" />
          Export as Excel
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
